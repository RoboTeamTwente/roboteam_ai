<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>roboteam_ai: World</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">roboteam_ai
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">World </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md84"></a>
General</h1>
<p><a href="https://github.com/RoboTeamTwente/roboteam_ai/blob/development/include/roboteam_ai/world_new/World.hpp#L36">World</a> by itself is a very interesting conversation, because we don't just have a single world. We have two worlds, one called <a href="http://github.com/roboteamtwente/roboteam_world">roboteam_world</a>, and one that we refer to as <a href="https://github.com/RoboTeamTwente/roboteam_ai/blob/development/include/roboteam_ai/world_new/World.hpp">ai world</a></p>
<p>The world structure simply represents the current world and the history. It keeps track of past worlds, and creates new worlds from <a href="https://developers.google.com/protocol-buffers">protobuf messages</a>.</p>
<p>The incoming protobuf messages are pushed back to the history through usage of the <a href="https://github.com/RoboTeamTwente/roboteam_ai/blob/development/include/roboteam_ai/world_new/World.hpp#L108">updateWorld</a> method.</p>
<p>updateWorld itself does <b>not</b> lock the world itself, that's the task of the caller. In a recent refactor I refactored the world to a way where it could not be used without acquiring a mutex, and therefore temporarily acquiring the only write and read access, which is something very important. Not doing so would result in data races.</p>
<p>The way the caller is forced to lock the world is through a static function called <a href="https://github.com/RoboTeamTwente/roboteam_ai/blob/development/include/roboteam_ai/world_new/World.hpp#L65">instance</a>. This function returns a structure of type <a href="https://github.com/RoboTeamTwente/roboteam_ai/blob/development/include/roboteam_ai/world_new/World.hpp#L52">AcquireInfo</a>.</p>
<p>This structure heavily relies on the principle of <a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a>, which is essentially <code>clean up after yourself</code>. It creates a scoped lock, which locks the mutex inside world, and until the <code>AcquireInfo</code> goes out of scope, it shall stay locked. The way this is done in code is the following.</p>
<p>The <code>auto const&amp; [x, y] = ...;</code> syntax below is called <a href="https://en.cppreference.com/w/cpp/language/structured_binding">structured binding</a>. It behaves like python tuple unpacking.</p>
<div class="fragment"><div class="line">def return_tuple() -&gt; (int, int):</div>
<div class="line">    return 1, 2</div>
<div class="line"> </div>
<div class="line">x, y = return_tuple()</div>
<div class="line"># x == 1</div>
<div class="line"># y == 2</div>
</div><!-- fragment --> <div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; [mtx, world_ptr] = World::instance();</div>
<div class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; [_, world_ptr] = World::instance();</div>
</div><!-- fragment --><p>You're not supposed to store this <code>world_ptr</code> anywhere unless this mutex is locked.</p>
<p>You cannot call <code>instance()</code> again until the current mutex is out of scope. Therefore instead of calling it again you usually just pass the <code>world_ptr</code> down the call stack.</p>
<h1><a class="anchor" id="autotoc_md85"></a>
Members</h1>
<p>World holds a variety of members.</p>
<p><code>HISTORY_SIZE</code> -&gt; Indicates the size of the history to be kept inside the world.</p>
<p><code>Settings</code> -&gt; Of type <code>Settings*</code>, therefore a non-owning instance of the settings structure. It's simply a reference (pointer) to it.</p>
<p><code>updateMutex</code> -&gt; Of type <code>std::mutex</code> as aforementioned this is simply the mutex used for acquiring an instance of the world ot preserve immutability</p>
<p><code>updateMap</code> -&gt; A hashmap of type <code>std::unordered_map&lt;uint8_t, ProtoFeedback&gt;</code> which maps the incoming feedback from the robots to their id, so we can apply this feedback when they get constructed. We get feedback from the robots directory for things like broken components and batteries.</p>
<p><code>history</code> -&gt; A <a href="https://en.wikipedia.org/wiki/Circular_buffer">circular buffer</a> used for storing past worlds, this buffer is appended to when <code>updateWorld</code> is called, given that there is a current world.</p>
<p><code>currentIndex</code> -&gt; A 64 bit unsigned integer which keeps track of the current index in <code>history</code>.</p>
<p><code>currentWorld</code> -&gt; The current world, as there is no guarantee that we have a current world, this is an optional value and therefore wrapped in <code>std::optional</code>. This is also the reason that getting the world data returns an optional view of it.</p>
<p><code>currentField</code> -&gt; the current field, represented in a structure. There will also be a wiki page on the field so check that one for more information. Like currentWorld there is no guarantee that we have a current representation of the field, therefore it's wrapped in an <code>std::optional</code>.</p>
<p><code>lastTick</code> -&gt; The time at which we got the previous tick from the networking socket. Unix timestamp in seconds.</p>
<p><code>tickDuration</code> -&gt; The difference between <code>lastTick</code> and the current incoming tick. Updated on data receive.</p>
<p><code>positionControl</code> -&gt; Robot position controller, used for communication between robots their positions.</p>
<h1><a class="anchor" id="autotoc_md86"></a>
Member functions</h1>
<p><code>World(Settings*)</code> -&gt; Constructs a world from the current settings, the only available constructor. Requires the <code>settings</code> parameter to not be a nullptr.</p>
<p><code>updateFeedback</code> -&gt; Updates the internal robot feedback hashmap from a new hashmap that's passed to this function. The hashmap is copied on invocation and then moved into the internal hashmap.</p>
<p><code>updateWorld</code> -&gt; This is the aforementioned method that updates the world. </p><div class="fragment"><div class="line"><span class="comment">// pseudo, not complete logic.</span></div>
<div class="line"><span class="keywordflow">if</span> (currentWorld.has_value()) {</div>
<div class="line">    history.emplace_back(currentWorld.value());</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    currentWorld = protoWorld;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>updateField</code> -&gt; Updates the internal <code>currentField</code> member from a new incoming protobuf Field.</p>
<p><code>updateField</code> -&gt; An overload of the previous updateField, instead it takes an <code>ai::world::Field</code> object reference and updates the internal world accordingly. Takes ownership of the original data. Ownership will be explained in a lecture about move semantics.</p>
<p><code>updatePositionControl</code> -&gt; Updates the internal <code>positionControl</code> using the new robot positions in the current world data representation.</p>
<p><code>getWorld</code> -&gt; Gets an optional pointer to <code>currentWorld</code>.</p>
<p><code>getField</code> -&gt; Returns <code>this-&gt;currentField</code></p>
<p><code>getHistoryWorld(index)</code> -&gt; Returns <code>this-&gt;history[index]</code></p>
<p><code>getTimeDifference</code> -&gt; Returns <code>tickDuration</code></p>
<p><code>getHistorySize</code> -&gt; Returns <code>history.size()</code>. <b>Not</b> guaranteed to be <code>HISTORY_SIZE</code>.</p>
<p><code>getRobotPositionController</code> -&gt; Returns a pointer to <code>positionControl</code>.</p>
<p><code>reset</code> -&gt; This function is only available if <code>RUNNING_TEST</code> is defined, and completely resets the world, usage outside of tests can and will result in undefined behavior.</p>
<p><code>updateTickTime</code> -&gt; Updates <code>lastTick</code> and <code>tickDuration</code></p>
<p><code>setWorld</code> -&gt; Sets <code>currentWorld</code> to the parameter.</p>
<p><code>toHistory</code> -&gt; Pushes a <code>world</code> to the history vector.</p>
<h1><a class="anchor" id="autotoc_md87"></a>
Advice for next year</h1>
<p>The world is really nice right now, it properly abstracts the hard parts away. It tries to guarantee shared immutability which is a very complicated topic and will be covered in one of the lectures, specifically about shared ownership and concurrency.</p>
<p>There's an issue where views persist to data that doens't exist anymore reglardless of the current mutex situation.</p>
<p>I'd return copies of WorldData, which could be wrapped like the following:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>WorldData {</div>
<div class="line">    <span class="comment">// ... stuff</span></div>
<div class="line">    WorldDataView view() { </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>; </div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ... stuff</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Then you can</p>
<div class="fragment"><div class="line">std::optional&lt;WorldData&gt; getWorld() { <span class="keywordflow">return</span> this-&gt;<a class="code" href="namespacertt_1_1world.html">world</a>; }</div>
<div class="line"> </div>
<div class="line">getWorld().value().<a class="code" href="namespacertt_1_1world_1_1view.html">view</a>()-&gt;...; <span class="comment">// stuff</span></div>
<div class="ttc" id="anamespacertt_1_1world_1_1view_html"><div class="ttname"><a href="namespacertt_1_1world_1_1view.html">rtt::world::view</a></div><div class="ttdef"><b>Definition:</b> FieldComputations.h:12</div></div>
<div class="ttc" id="anamespacertt_1_1world_html"><div class="ttname"><a href="namespacertt_1_1world.html">rtt::world</a></div><div class="ttdef"><b>Definition:</b> IOManager.h:17</div></div>
</div><!-- fragment --><p>I don't know there's a lot of ways you could approach this but returning a copy is one of the few where immutable safety is guaranteed (don't use shared ptr pls).</p>
<p>My advice is simple.</p><ul>
<li>Update the history to be an <code>std::array</code> instead of <code>std::vector</code>.</li>
<li>[Optional] Return copies of data so you don't rely on the user using it correctly. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
