<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>roboteam_ai: Path Planning Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">roboteam_ai
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Path Planning Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this module is to compute a path for each robot, that manages to avoid obstacles (other robots, the defense area, staying inside the field, etc.) and, using velocity control, have the robot reach its destination as fast as possible. The structure is divided into multiple parts:</p><ul>
<li>Path Planning;</li>
<li>Path Tracking;</li>
<li>Collision Detection;</li>
<li>The integration of all of the above.</li>
</ul>
<h1><a class="anchor" id="autotoc_md33"></a>
Path Planning</h1>
<p>The purpose of the Path Planning algorithm is to generate a path / paths that the current robot has to follow, in order to reach its destination without colliding with obstacles. The path is implemented as a tree, containing the position of the node (<em>consider adding more information - like the time needed to get there</em>) and the node's parent (the root will have a null parent). By calling the collision detector, a new point can be evaluated in terms of collisions, to which the distance to the goal, cost to get there, etc. can be added to determine whether it should be added to the path or not.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Current Implementation</h2>
<ol type="1">
<li>Check if the current path point is valid for the path (whether there is a collision between the current point and its parent)</li>
<li>If there are collisions, determine the collision point and branch to the sides of the obstacle. Add the 2 new candidates to a path queue and go back to step 1</li>
<li>If there are no collisions, update the current best path (in case the current point is closer to the destination than the previous best)</li>
<li>From the current position, we trace a path directly to the target position and repeat step 2</li>
<li>If there are no collisions to reach the target, return the path</li>
<li>The algorithm ends when:</li>
</ol>
<ul>
<li>A path to the target is found</li>
<li>The algorithm reaches a maximum number of iterations or branches too much (returning the current best path)</li>
<li>The current point is close (e.g. within 10cm) of the target (returning the current path)</li>
</ul>
<p>The algorithm currently ignores the points that are outside of the field. The result is a sparse path that avoids obstacles according to some avoidance distance (the branching distance from the collision point).</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Path Tracking</h1>
<p>After obtaining the path, a velocity and angle has to be computed (as the robots use velocity control). Depending on the planning algorithm, the path may or may not be smooth, so the robot will experience bottlenecks on the corners. The purpose of this module is following a given path as efficiently as possible.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Current Implementation</h2>
<ol type="1">
<li>Remove the first point in the path if it has been reached (distance &lt; some threshold)</li>
<li>The velocity is computed by filtering the difference between the current position and the target position through a decoupled PID controller.</li>
<li>The parameters of the filter are taken directly from the interface, depending on the PID type needed (e.g. the keeper will have different PID values than default).</li>
</ol>
<h1><a class="anchor" id="autotoc_md37"></a>
Collision Detector</h1>
<p>Contains helper functions to determine:</p><ul>
<li>robot collisions (and their position - currently returns only the collision with the first robot ID, consider taking the closest collision)</li>
<li>collision with the defense area (and its position)</li>
<li>whether a point is in field or not</li>
</ul>
<p>These helper functions are just a wrapper for the field computation functions.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Integration</h1>
<p>The main module just creates all the above modules and is responsible for their life cycle + calling them in the right order. Also, it incorporates some extra checks:</p><ol type="1">
<li>If the target is outside of the field, no path is computed.</li>
<li>If the robot is close to the target, but can't reach it due to collisions, it will not ram the obstacle (no further path)</li>
<li>A path is recomputed if either one of these conditions is true:</li>
</ol>
<ul>
<li>there is no path</li>
<li>the target changed</li>
<li>a collision is detected between the moving robot and its next path way point</li>
</ul>
<h1><a class="anchor" id="autotoc_md39"></a>
Improvements</h1>
<p>Consider experimenting with / researching different algorithms for different tasks. Consider also using different algorithms for each robot (and think before whether it would be better to have separate algorithms for each robot or not). Ideas:</p><ol type="1">
<li>Path Planning</li>
</ol>
<ul>
<li>Voronoi (slow for many robots, also large avoidance - an implementation already exists in the code base)</li>
<li>Split the search area into grids and check grid occupancy</li>
<li>RRT* augmented with Particle Swarm (or other RRT implementations - many teams use RRT for their path planning)</li>
<li>Magnetic field lines (basically smart picking for RRT - draw magnetic field lines from the current position to the target and sample points from these lines to try to build a path)</li>
</ul>
<ol type="1">
<li>Path Tracking</li>
</ol>
<ul>
<li>Pure Pursuit (use a look ahead distance to try to track a path)</li>
<li>Fast Marching (personally I didn't understand this, but there are papers on it)</li>
<li>Bezier (interpolate the path points and take the path derivative(?) to track it)</li>
<li>Potential Field (each obstacle gives a repelling force proportional to distance, while the goal has an attracting force - maybe combine with planning)</li>
<li>Couple the PID controllers together - also taking into account the robots maximum velocity</li>
<li>Bang bang control (Simplify the control into Accelerate/Decellerate at the highest rate and coasting at the maximal velocity and choose one of these 3 )</li>
</ul>
<ol type="1">
<li>Others</li>
</ol>
<ul>
<li>Maybe the velocity can be computed directly in the path planning, according to different metrics, and then the tracking can just filter the velocity or something</li>
<li>Ignoring collisions for far away points (e.g. after 3seconds of path or 2m away)</li>
<li>Extend the current implementation by taking into account the time needed to reach the points (or use other metrics to compare paths)</li>
<li>Rewrite the collision detector to consider custom areas to avoid (specified either by flags or passing an array of shapes to it) </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
